<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta name="og:site_name" content="Swift Package Index Blog"/><link rel="canonical" href="https://blog.swiftpackageindex.com"/><meta name="twitter:url" content="https://blog.swiftpackageindex.com"/><meta name="og:url" content="https://blog.swiftpackageindex.com"/><title>Swift Package Index Blog</title><meta name="twitter:title" content="Swift Package Index Blog"/><meta name="og:title" content="Swift Package Index Blog"/><meta name="description" content="    The Swift Package Index is the place to find Swift packages.
    The project is open-source and community driven, and this blog tells the story of its development."/><meta name="twitter:description" content="    The Swift Package Index is the place to find Swift packages.
    The project is open-source and community driven, and this blog tells the story of its development."/><meta name="og:description" content="    The Swift Package Index is the place to find Swift packages.
    The project is open-source and community driven, and this blog tells the story of its development."/><meta name="twitter:card" content="summary"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css" type="text/css"/><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,400;0,600;0,700;1,400;1,600;1,700&display=swap" type="text/css"/><link rel="stylesheet" href="/main.min.css?1598031844" type="text/css"/><script src="/main.min.js?1598031844"></script><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="shortcut icon" href="/images/favicon.png" type="image/png"/><link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Swift Package Index Blog"/>    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
    j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
    'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-T2KRSKX');</script></head><body>    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-T2KRSKX"
    height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><header><div class="inner"><a href="/"><h1><img src="/logo.svg"/>The Swift Package Index Blog</h1></a><nav><a href="https://swiftpackageindex.com">Visit the Swift Package Index</a></nav></div></header><main><div class="inner"><h2 class="post"><a href="/posts/launching-language-and-platform-package-compatibility">Launching Language and Platform Package Compatibility</a></h2><small>Posted <a href="/posts/launching-language-and-platform-package-compatibility">Thursday, August 20, 2020</a>.</small><hr class="post"></hr><p>Whatâ€™s the first question you need an answer to after finding a package that fits your needs?</p><blockquote><p>â€œDoes this package work with the Swift version and platform that my app uses?â€</p></blockquote><p>When we initially launched the Swift Package Index, we attempted to answer this question with the metadata available in the package manifest. Namely the <a href="https://developer.apple.com/documentation/swift_packages/package/3197887-swiftlanguageversions"><code>swiftLanguageVersions</code></a> and <a href="https://developer.apple.com/documentation/swift_packages/package/3197886-platforms"><code>platforms</code></a> properties.</p><p>The problem is that neither of those properties is perfect. <code>swiftLanguageVersions</code> isnâ€™t granular enough, only <a href="https://developer.apple.com/documentation/swift_packages/swiftversion">officially</a> allowing values of <code>v4</code>, <code>v4_2</code>, and <code>v5</code>. The <code>platforms</code> property is better, but doesnâ€™t let package authors declare compatibility with non-Apple operating systems such as Linux.</p><p>Wouldnâ€™t it be fantastic if you could see a matrix like this for <em>every</em> package? ğŸ˜</p><picture>
  <source srcset="/images/promisekit-language-and-platform-metadata~dark.png" media="(prefers-color-scheme: dark)">
  <img src="/images/promisekit-language-and-platform-metadata~light.png" alt="The language and platform compatibility matrix for PromiseKit.">
</picture><p>Look at how information-rich that matrix is. You can instantly see that the latest stable version of <a href="https://swiftpackageindex.com/mxcl/PromiseKit">PromiseKit</a> is compatible with every version of Swift back to 4.2, and every platform, including Linux. Then, you can see that the alpha version in development drops support for iOS, tvOS, and watchOS, and Swift 4.2. That seems suspicious, right? Keep looking, and youâ€™ll see that the default branch fixes all those issues and restores compatibility. Iâ€™m confident looking at that matrix that when 7.0.0 is released, itâ€™ll have green ticks across the board, but I also know to not depend on this current alpha. Thatâ€™s practical, actionable information.</p><p>When we started thinking about how best to solve this problem, the obvious best solution was to build the packages! What better way to see if a package is compatible with Swift 4.2 than to build it with the version of <code>xcodebuild</code> that shipped with Xcode 10.1.</p><p>So thatâ€™s what we did, and itâ€™s available right now. Why not <a href="https://swiftpackageindex.com">give it a try</a> by searching for a few of your favourite packages? ğŸš€</p><h3>Accurate, real-world compatibility data</h3><p>Itâ€™s a little more complicated than â€œjust build each packageâ€ though. A package might build with Swift 5.2 on iOS, but that same build might fail using Swift 5.2 on macOS due to a UIKit dependency, or other macOS specific issue. Whatâ€™s needed is a <em>matrix</em> of builds to generate an accurate picture of compatibility.</p><p>So, if we run builds using Swift 5.1 on iOS, macOS, tvOS, watchOS, and with Linux and <em>any</em> of them pass, itâ€™s compatible with Swift 5.2. If <em>any</em> version of Swift builds without failure on iOS, then the package supports iOS.</p><p>We ended up with a platform list of:</p><ul><li>iOS using <code>xcodebuild</code></li><li>macOS using <code>xcodebuild</code></li><li>macOS using <code>swift build</code> (there are good reasons where <code>swift build</code> would pass in circumstances where <code>xcodebuild</code> might fail)</li><li>macOS using <code>xcodebuild</code> on Apple Silicon (yes, compiled using a DTK!)</li><li>macOS using <code>swift build</code> on Apple Silicon</li><li>tvOS using <code>xcodebuild</code></li><li>watchOS using <code>xcodebuild</code></li><li>Linux using <code>swift build</code></li></ul><p>We then decided on a list of Swift compiler versions weâ€™d like to check compatibility with:</p><ul><li>Swift 4.2 (4.2.1)</li><li>Swift 5.0 (5.0.1)</li><li>Swift 5.1 (5.1.3)</li><li>Swift 5.2 (5.2.4)</li><li>Swift 5.3 (beta)</li></ul><p>Thatâ€™s up to 32 builds per package, but thatâ€™s just the beginning. What if thereâ€™s a stable release and a beta release? The stable version might support Swift 4.2 and higher, and the new beta might drop support for anything less than Swift 5.2. Thatâ€™s information which would be important when choosing a package, so we need to show it. As we also track the status of the default branch, we must build that too, and weâ€™ve quickly arrived at a place where we might need to run 96 builds <em>per package</em>! With almost 3,200 packages in the index, thatâ€™s potentially more than 300,000 builds! ğŸ˜…</p><p>In practice, itâ€™s less than that as most packages donâ€™t have a current beta release, but itâ€™s still a <em>lot</em> of builds. Weâ€™ve processed more than 200,000 builds as I write this, and weâ€™re not quite finished. As of today, weâ€™re at 99% though, so we almost made it before launch! ğŸ˜¬</p><p>If youâ€™ve been following <a href="https://twitter.com/daveverwer/status/1291808885259620353">these tweets</a>, it should be obvious what all that processing was! Letâ€™s take a look at the last <strong>30 days</strong> of CPU graphs for our production server, a 2018 Mac mini with 32Gb RAM and a 6-core i7 CPU:</p><img src="/images/production-server-thirty-day-cpu-graph.png" alt="A graph showing a few spikes of CPU activity, followed by a sustained 100% CPU load."/><p>You can see a few of our final test runs in that graph, and then we started processing for real. Since then, weâ€™ve kept the CPU completely pegged for more than two weeks. Weâ€™ve also had our staging Mac mini, a spare 2016 MacBook Pro, and a DTK working on builds too.</p><h3>Everyone loves badges</h3><p>Providing compatibility information on this site is one thing, but everyone loves adorning their packages pages with <a href="https://shields.io">shields.io</a> badges, donâ€™t they? If you maintain an open-source project, wouldnâ€™t you like to show off real compatibility status in your README file, like this?</p><img src="/images/rester-readme-with-spi-badges.png" alt="A screenshot of a GitHub page with badges that show the Swift and platform compatibility for the package."/><p>If youâ€™re a package author, click the â€œCopy badgeâ€ button below each of the compatibility matrices and youâ€™ll have a Markdown image link in your clipboard, ready to use.</p><p>Your users will always see live, accurate compatibility information that updates whenever you release a new version.</p><h3>Credit where itâ€™s due!</h3><p>First of all, weâ€™d like to thank our kind friends at <a href="https://macstadium.com">MacStadium</a> for providing the significant hosting resources for this project as part of their <a href="https://www.macstadium.com/opensource">open-source programme</a>. At one point we were a little concerned that we might melt their machines, and we very glad that we didnâ€™t. Theyâ€™ve performed incredibly.</p><p>We also want to say thank you to <a href="https://twitter.com/aciidb0mb3r">Ankit Aggarwal</a> and <a href="https://twitter.com/neonacho">Boris BÃ¼gling</a> of Apple. Their tireless help and support on the <a href="https://swift-package-manager.herokuapp.com">SwiftPM Slack</a> saved us countless hours figuring out the correct way to approach this problem.</p><p>Finally, weâ€™d love to say thank you to everyone who provided help and feedback along the way as we built this feature. We couldnâ€™t have done it without any of you.</p><h3>Wrapping up</h3><p>Some package authors set up continuous integration for their packages and of course, that includes a build step. That usually only covers one version of Swift though, and the information gets hidden away in a different place in each repo. We think that by centralising this data and making it available for <em>all</em> packages, we should be able to help this community make better decisions about their dependencies, and thatâ€™s what this site is all about.</p><p>We hope you love this feature as much as we do! â¤ï¸</p><hr/><h2 class="post"><a href="/posts/say-hello-to-the-swift-package-index-blog">Say Hello to the Swift Package Index Blog</a></h2><small>Posted <a href="/posts/say-hello-to-the-swift-package-index-blog">Sunday, August 16, 2020</a>.</small><hr class="post"></hr><p>Hello! ğŸ‘‹</p><p>Itâ€™s always hard to know when to ship v1 of a project. Which features get included? Are there things that can wait? Itâ€™s a balancing act. Youâ€™re excited to show the world what you built, but is it good enough?</p><p>One decision we made when shipping the <a href="https://swiftpackageindex.com">Swift Package Index</a> was that a blog could wait. Looking back now, it feels like that was the right decision. The launch went smoothly, you all reacted very kindly and positively to it, and we went back to work fixing bugs and working on new features.</p><p>However, we always knew weâ€™d need somewhere to write about what we are doing with this project. Weâ€™d love to tell you about some of the interesting technical challenges we faced, but most of all we want to tell you about the new features weâ€™ve been building...</p><p>What features? Youâ€™ll have to wait just one more week to find out what weâ€™ve been working on, but weâ€™re pretty excited about it, and thatâ€™s why now was the right time to launch this blog.</p><p class="dim">Now we just need to keep writing on it! ğŸ˜¬</p><hr/><div class="what">The <a href="https://swiftpackageindex.com">Swift Package Index</a> is a search engine for Swift packages with one goal. <strong>To help you make better decisions about dependencies.</strong> For more information, the best place to start is with the <a href="https://swiftpackageindex.com/faq">Frequently Asked Questions</a>.</div></div></main><footer><div class="inner"><nav><ul><li><a href="https://swiftpackageindex.com/privacy">Privacy and Cookies</a></li><li><a href="https://twitter.com/swiftpackages">Twitter</a></li></ul><small><a href="https://macstadium.com/">Kindly hosted by MacStadium</a></small></nav></div></footer></body></html>