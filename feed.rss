<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content"><channel><title>Swift Package Index Blog</title><description>    The Swift Package Index is the place to find Swift packages.
    The project is open-source and community driven, and this blog tells the story of its development.</description><link>https://blog.swiftpackageindex.com</link><language>en</language><lastBuildDate>Wed, 5 May 2021 10:57:16 +0000</lastBuildDate><pubDate>Wed, 5 May 2021 10:57:16 +0000</pubDate><ttl>250</ttl><atom:link href="https://blog.swiftpackageindex.com/feed.rss" rel="self" type="application/rss+xml"/><item><guid isPermaLink="true">https://blog.swiftpackageindex.com/posts/launching-the-swift-package-index-playgrounds-app-for-macos</guid><title>Launching the Swift Package Index Playgrounds app for macOS</title><description>How did the Swift Package Index project get started, and why does a button feature so prominently in the story? Read on to find out.</description><link>https://blog.swiftpackageindex.com/posts/launching-the-swift-package-index-playgrounds-app-for-macos</link><pubDate>Wed, 5 May 2021 13:00:00 +0000</pubDate><content:encoded><![CDATA[<p>From the very beginning, the main goal of this site was to do more than echo Swift package metadata. We want to enable better <em>decisions</em> about which dependencies to use. That‚Äôs why we include information about how actively maintained a package is, and it‚Äôs why we check compatibility with the different platforms by building against them.</p><p>Once you‚Äôve decided that a package might be a good fit for your project, what‚Äôs your next step? Do you import it and start coding against it?</p><p>There‚Äôs a better way.</p><p>What if you could click a button and open Xcode with a Swift playground that has the library you‚Äôre thinking of using already imported? That‚Äôs what we‚Äôre launching today with the <a href="https://swiftpackageindex.com/try-in-a-playground">Swift Package Index Playgrounds</a> app.</p><p>Once you have installed the app, click ‚ÄúTry in a Playground‚Äù from any package page.</p><picture class="shadow">
  <source srcset="/images/try-in-a-playground-package-page~dark.png" media="(prefers-color-scheme: dark)">
  <img src="https://blog.swiftpackageindex.com/images/try-in-a-playground-package-page~light.png" alt="The Swift Package Index site with the Try in a Playground button highlighted">
</picture><p>Then click "Create Playground" when the app launches.</p><picture>
  <source srcset="/images/spi-playgrounds-app~dark.png" media="(prefers-color-scheme: dark)">
  <img src="https://blog.swiftpackageindex.com/images/spi-playgrounds-app~light.png" alt="The Swift Package Index Playgrounds app running on macOS">
</picture><p>Choose where to save it, and a few seconds later, the playground will open in Xcode, ready for experimentation and testing! We‚Äôd love to know if this is a helpful feature, so be sure to <a href="https://twitter.com/SwiftPackages">let us know on Twitter</a>.</p><p>There‚Äôs also an amusing story behind this feature, which prompted us to write up the <a href="https://blog.swiftpackageindex.com/posts/how-the-swift-package-index-project-got-started">story behind ‚ÄúThe Button‚Äù</a>.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://blog.swiftpackageindex.com/posts/how-the-swift-package-index-project-got-started</guid><title>How the Swift Package Index project got started because of a button</title><description>How did the Swift Package Index project get started, and why does a button feature so prominently in the story? Read on to find out.</description><link>https://blog.swiftpackageindex.com/posts/how-the-swift-package-index-project-got-started</link><pubDate>Wed, 5 May 2021 12:00:00 +0000</pubDate><content:encoded><![CDATA[<p>It‚Äôs been <a href="https://twitter.com/_sa_s/status/1386033811348197380">one year since we made the first commit</a> on the <a href="https://github.com/SwiftPackageIndex/SwiftPackageIndex-Server">Swift Package Index repository</a>, and we think that deserves a little celebration!</p><center style="font-size: 30px;">üéÇ</center><p>Did you enjoy the cake? üòÇ No? Well, how about we also tell you the story of how this project started?</p><p><strong>Note:</strong> We usually write blog posts here in the first person plural as this project is very much a joint effort, but this is a story with lots of references to both <a href="https://twitter.com/daveverwer">Dave</a> and <a href="https://twitter.com/_sa_s">Sven</a> individually, so I‚Äôll write it in the first person singular. <em>Dave</em></p><p>Before the Swift Package Index, there was the <a href="https://daveverwer.com/blog/launching-the-swiftpm-library/">SwiftPM Library</a>. The goal of that site was the same as this one, to provide a comprehensive index of Swift packages that helps you make better decisions about your dependencies.</p><p>A little while after the launch, I had a message from some members of the <a href="https://discord.com/invite/vapor">Vapor Discord</a>. They had been chatting about creating something similar as an open-source Swift/Vapor project and wondered if I might be interested in collaborating on it. I‚Äôll admit that I wasn‚Äôt hugely excited about rewriting a site that I had just launched, but I was in favour of it becoming open-source. However, the reality of an open-source project focused on indexing Swift packages being a Ruby project would make finding contributors challenging, so I put aside my doubts and decided to go for it. I started learning Vapor and got started. Unfortunately, circumstances worked against the rewrite being a success at that point. I found the Vapor learning curve tough while also maintaining the existing site, and the folks from the Vapor Discord were busy too. The project started to progress, but slowly.</p><p>That‚Äôs when I got an email from Sven. He had seen the SwiftPM Library and wondered if I might be open to integrating his open-source project, <a href="https://github.com/finestructure/Arena">Arena</a>, with it. His idea was to add a button next to each search result that, when clicked, would create a Swift Playground that imported the library, ready for experimentation. It was a great idea, and we ended up on a quick audio call a few days later to discuss it. While we chatted, I mentioned the potential rewrite of the SwiftPM Library into Swift/Vapor, and it turned into a much larger conversation. Sven was interested in the project, experienced working with Vapor, and keen to help. A winning combination! ü•á</p><p>Things progressed very quickly after that. I wrote up some details of how the existing project worked, and Sven worked his Vapor magic. Before too long, we had a prototype up and running, and the project started to feel real. There wasn‚Äôt time to add ‚Äúthe Arena button‚Äù as we needed to get the basics implemented first, but it remained firmly on the to-do list.</p><p>Sven and I ended up working really well together. We had different, complementary skill sets, and we progressed quickly towards getting the new project finished. It had been open-source from day one, and we were working in public, but no one had noticed, and we started to gear up for the <a href="https://iosdevweekly.com/issues/460#start">launch of the Swift Package Index</a>.</p><p>There was still no sign of ‚Äúthe button‚Äù, though, even many months after the launch. üò¨</p><p>It wasn‚Äôt through any malice or deliberate neglect. It was just that there was always something else that took a slightly higher priority. We worked on <a href="https://blog.swiftpackageindex.com/posts/launching-language-and-platform-package-compatibility">language and platform compatibility reporting</a>, <a href="https://blog.swiftpackageindex.com/posts/building-3238-packages-for-apple-silicon">Apple silicon builds</a>, <a href="https://blog.swiftpackageindex.com/posts/the-swift-package-index-metadata-file-first-steps">gathering additional metadata</a>, <a href="https://blog.swiftpackageindex.com/posts/funding-the-future-of-the-swift-package-index">funding the project</a>, <a href="https://blog.swiftpackageindex.com/posts/keeping-up-to-date-with-swift-packages">RSS feeds</a>, <a href="https://blog.swiftpackageindex.com/posts/inline-readme-files">inline README files</a>, <a href="https://blog.swiftpackageindex.com/posts/hosting-the-swift-package-index">finding suitable hosting</a>, and <a href="https://github.com/SwiftPackageIndex/SwiftPackageIndex-Server/pulls?q=is%3Apr+is%3Aclosed">many more things</a> that didn‚Äôt make it to the blog.</p><p>I‚Äôm delighted to say that today sees the launch of ‚Äúthe button‚Äù! But what does the button do? Read more about that in the <a href="https://blog.swiftpackageindex.com/posts/launching-the-swift-package-index-playgrounds-app-for-macos">official launch post</a>.</p><p>That deserves more than a cake! ü•Çüçæ</p><p>I‚Äôm happy that we <strong>finally</strong> got to bring Sven‚Äôs original idea to fruition through this project, but this celebration is about much more than that! Working with Sven on this project has been a pleasure from the beginning. We work incredibly well together and are making something that feels significant and important. The button is part of that, but the potential of the site is so much more.</p><p>It‚Äôs also worth mentioning that if you want to hear Sven and I talk about this story in person, we <a href="https://swiftbysundell.com/podcast/75/">discussed it on John Sundell‚Äôs podcast</a> last year.</p><p>Here‚Äôs to year two!</p>]]></content:encoded></item><item><guid isPermaLink="true">https://blog.swiftpackageindex.com/posts/hosting-the-swift-package-index</guid><title>Hosting the Swift Package Index</title><description>Making any open-source project sustainable for the long term is challenging in many ways, but with the Swift Package Index we also need significant hardware resources to keep it available.</description><link>https://blog.swiftpackageindex.com/posts/hosting-the-swift-package-index</link><pubDate>Tue, 30 Mar 2021 12:00:00 +0000</pubDate><content:encoded><![CDATA[<img src="https://blog.swiftpackageindex.com/images/hosted-by-macstadium-and-microsoft-azure.png" alt="Logo images for the Swift Package Index, MacStadium, and Microsoft Azure"/><p>Making any open-source project sustainable for the long term is challenging. You need to find time to work on the code, plan out features, respond to feedback, and if the project is not only code but a live web site, it also needs hosting and regular maintenance.</p><p>The Swift Package Index has slightly bigger hosting problems than most web sites, too. In addition to web and database servers, we need a significant amount of processing power to monitor and analyse constant package releases and run our build machines that deal with the ~30,000 Swift builds per month that process through our <a href="https://blog.swiftpackageindex.com/posts/launching-language-and-platform-package-compatibility/">compatibility build system</a>. üòÖ</p><p>We‚Äôre delighted to say that as of today, all of the Swift Package Index‚Äôs hosting problems are taken care of thanks to the generosity of two companies that believe in open-source.</p><p>First, <a href="https://macstadium.com">MacStadium</a>. The site has run on their Mac mini infrastructure since the <a href="https://twitter.com/daveverwer/status/1271447550936186882">public launch</a> through their <a href="https://www.macstadium.com/opensource">open-source programme</a>. They have accommodated every request we have made, including giving us access to a DTK, which enabled <a href="https://blog.swiftpackageindex.com/posts/building-3238-packages-for-apple-silicon/">Apple silicon compatibility results</a> months in advance of M1 machines becoming available. They are a pleasure to work with and consistently supportive. Thank you to Heather, Brian, and all of the support team at MacStadium.</p><p>However, while running the web hosting, the database, package update monitoring, Linux builders, and all the Apple builders all on the same hardware is possible, it‚Äôs not ideal. Our build queue had become quite delayed because we were asking those Mac minis to do too much.</p><p>That‚Äôs where <a href="https://azure.microsoft.com">Microsoft Azure</a> stepped in. We have now eased the load by migrating our web hosting and Linux builders to Azure. The site is load balanced and redundant, which not only increases speed and availability, it also decreases the maintenance effort required. Working with Microsoft has been an absolute pleasure, and their only priority was to see the project succeed. Nothing was too much trouble. Thank you to Stormy, Thomas, Shelby, and Candice.</p><p>With the web servers, database, package update monitoring, and Linux builders hosted at Azure and the macOS, macOS ARM, iOS, tvOS, and watchOS builders at MacStadium, the hosting for this project is secure and stable for the foreseeable future. Thank you so much to both companies for their help. Running this site wouldn‚Äôt be possible without them.</p><p><strong>Note:</strong> It‚Äôs worth mentioning that this blog post is not a condition of any agreement between us and either of these companies. All this support came without any expectation of anything other than enabling an open-source project. We are writing this purely because we are grateful for their help. ‚ù§Ô∏è</p>]]></content:encoded></item><item><guid isPermaLink="true">https://blog.swiftpackageindex.com/posts/whats-next-february-2021</guid><title>What‚Äôs next? February 2021</title><description>It‚Äôs been about seven months since we launched the Swift Package Index and we‚Äôve been hard at work implementing a few major updates. Are we done? No, we are not!</description><link>https://blog.swiftpackageindex.com/posts/whats-next-february-2021</link><pubDate>Tue, 2 Feb 2021 12:00:00 +0000</pubDate><content:encoded><![CDATA[<p>It‚Äôs been about seven months since we <a href="https://iosdevweekly.com/issues/460#start">launched the Swift Package Index</a> and we‚Äôve been hard at work implementing a few major updates. Most significantly, <a href="https://blog.swiftpackageindex.com/posts/launching-language-and-platform-package-compatibility">real-world package compatibility</a>, <a href="https://blog.swiftpackageindex.com/posts/keeping-up-to-date-with-swift-packages">a comprehensive set of RSS feeds and Twitter updates</a>, and most recently <a href="https://blog.swiftpackageindex.com/posts/inline-readme-files">inline README files</a>.</p><p>But we‚Äôre far from done! üòÖ</p><p>So, in the spirit of letting you all know what we‚Äôre planning for this project next, we wanted to start a regular series of blog posts about the direction we‚Äôre heading with feature development. We‚Äôll post every couple of months, giving a quick recap of what we‚Äôve achieved along with where we‚Äôre heading next. It‚Äôs not a formal roadmap. It‚Äôs more a declaration of where our focus will be for the next couple of months.</p><p>So without further ado, what are we focusing on next?</p><h2>Intermediate Search Page</h2><p>Currently, search results are displayed inline on the home page, which makes it hard to share package searches (there‚Äôs no URL for a search), or integrate with productivity tools like Alfred or Raycast, or even DuckDuckGo through their <a href="https://duckduckgo.com/bang">bangs feature</a>. We want to fix that.</p><h2>Package Collections</h2><p>If you‚Äôve been following the <a href="https://github.com/apple/swift-evolution/blob/main/proposals/0291-package-collections.md">package collection work</a> in the SPM project, then it might have struck you that the Swift Package Index would be a great source of package collections, when they are added. We agree! We‚Äôve already been working hard to prepare for this feature and want to have something publicly available as soon as the feature becomes available in SPM.</p><h2>Design updates</h2><p>The site design suited our feature set at launch but has become a little overloaded as we added features. This work has already started, with a new package page layout rolling out last Friday. There‚Äôs more to do though, including improvements to the home page. The lists of recent package additions and recent package releases are fine, but we can do better!</p><h2>The Swift Package Index macOS App</h2><p>We‚Äôve always wanted to create a Swift Package Index Mac app of some kind. The app‚Äôs main purpose would be to allow you to easily try packages out in a Swift Playground (utilising the wonderful <a href="https://swiftpackageindex.com/finestructure/Arena">Arena</a> tool). But it might end up being more over the long term. We want to define what this app will do, and then get something out that works towards that definition. We talked about the interesting story behind the ‚ÄúTry this package‚Äù feature <a href="https://www.swiftbysundell.com/podcast/75/">on John Sundell‚Äôs podcast last year</a> if you‚Äôre interested!</p><h2>And More‚Ä¶</h2><p>This is not a comprehensive list of things we‚Äôll do. This is a young project, and we want to keep development agile. If we have a great idea, it may go into the plan ahead of everything you read above!</p><h2>Thank you!</h2><p>We‚Äôd also like to use this update post to say a huge thank you to our generous sponsors. We wouldn‚Äôt be able to put in the time and effort needed by this project without the generous support of <a href="https://github.com/Timac">Alexandre Colucci</a>, <a href="https://github.com/dive">Artem Loenko</a>, <a href="https://github.com/bdolewski">Bartosz Dolewski</a>, <a href="https://github.com/neonichu">Boris B√ºgling</a>, <a href="https://github.com/welsh11">Byron Davies</a>, <a href="https://github.com/csjones">Chris</a>, <a href="https://github.com/dasdom">Dominik Hauser</a>, <a href="https://github.com/zntfdr">Federico Zanetello</a>, <a href="https://github.com/shgew">Gleb Shevchenko</a>, <a href="https://github.com/Sherlouk">James Sherlock</a>, <a href="https://github.com/jabruder">Jason Bruder</a>, <a href="https://github.com/mackoj">Jeffrey Macko</a>, <a href="https://github.com/heckj">Joseph Heck</a>, <a href="https://github.com/jkaunert">Joshua Kaunert</a>, <a href="https://github.com/Juanpe">Juanpe Catal√°n</a>, <a href="https://github.com/jcoynel">Jules Coynel</a>, <a href="https://github.com/Kilo-Loco">Kyle Lee</a>, <a href="https://github.com/leopic">Leo Picado</a>, <a href="https://github.com/marcosgriselli">Marcos Griselli</a>, <a href="https://github.com/massimobio">Massimo Biolcati</a>, <a href="https://github.com/mkj-is">Matƒõj Ka≈°par Jir√°sek</a>, <a href="https://github.com/MaxDesiatov">Max Desiatov</a>, <a href="https://github.com/Mordil">Nathan Harris</a>, <a href="https://github.com/odrobnik">Oliver Drobnik</a>, <a href="https://github.com/Patrik-svobodik">PatrikTheDev</a>, <a href="https://github.com/paulfarnell">Paul Farnell</a>, <a href="https://github.com/twostraws">Paul Hudson</a>, <a href="https://github.com/steipete">Peter Steinberger</a>, <a href="https://github.com/PSPDFKit">PSPDFKit</a>, <a href="https://github.com/rileytestut">Riley Testut</a>, <a href="https://github.com/robinkunde">Robin Kunde</a>, <a href="https://github.com/samsymons">Sam Symons</a>, <a href="https://github.com/ScottRobbins">Scott Robbins</a>, <a href="https://github.com/StefanCosminR">Stefan-Cosmin Romanescu</a>, <a href="https://github.com/ashtom">Thomas Dohmke</a>, <a href="https://github.com/0xTim">Tim Condon</a>, <a href="https://github.com/Umar-M-Haroon">Umar Haroon</a>, <a href="https://github.com/shpakovski">Vadim Shpakovski</a>, and <a href="https://github.com/xavierLowmiller">Xavier Lowmiller</a>. Thank you all! ‚ù§Ô∏è</p><p>Would you like to be part of this list next time we post an update like this? <a href="https://github.com/sponsors/SwiftPackageIndex">Sponsoring the Swift Package Index</a> is done through GitHub Sponsors, and your support will allow us to continue to build this site into something special.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://blog.swiftpackageindex.com/posts/inline-readme-files</guid><title>Inline README Files!</title><description>Where‚Äôs the most important source of information for deciding whether a package is suitable for your needs? It‚Äôs in the README file!</description><link>https://blog.swiftpackageindex.com/posts/inline-readme-files</link><pubDate>Thu, 24 Dec 2020 12:00:00 +0000</pubDate><content:encoded><![CDATA[<p>If you‚Äôve visited the main package index site over the last week or so, you might have noticed something new. Scroll down a little, and you‚Äôll see the README file for the package, right below all the other information that we aggregate.</p><p>When we consider adding a new feature, at the heart of our decision has to be the question ‚ÄúDoes this feature allow people to make better decisions about the package they‚Äôre considering?‚Äù Rather embarrassingly, the README file is probably <em>the most</em> important piece of information when picking a package dependency. Let‚Äôs not focus on that though, and instead be thankful that we finally got around to adding it! üòÖ</p><p>We‚Äôre aware of a couple of problems with README files that <a href="https://github.com/SwiftPackageIndex/SwiftPackageIndex-Server/issues/843">contain embedded HTML</a> or make use of <a href="https://github.com/SwiftPackageIndex/SwiftPackageIndex-Server/issues/824">in-page anchor links</a> that are often used to build a table of contents. We‚Äôll get those fixed over time, but decided that it was worth rolling the feature out even with a couple of remaining issues.</p><p>Of course, we‚Äôve not been able to test every single README file, so If you notice any other issues, please let us know by <a href="https://github.com/SwiftPackageIndex/SwiftPackageIndex-Server/issues/new/choose">opening an issue</a>.</p><p>Thank you all for your support this year, and we hope you enjoy this feature that brings our year of development on the Swift Package Index to an end. We can‚Äôt wait to show you what we have planned for 2021!</p>]]></content:encoded></item><item><guid isPermaLink="true">https://blog.swiftpackageindex.com/posts/keeping-up-to-date-with-swift-packages</guid><title>Keeping Up To Date with Swift Packages</title><description>How do you keep up with new releases of the packages you use? How do you discover new packages? It‚Äôs a tough challenge to keep up to date with everything that the community releases, so we have some announcements today that can help you stay informed!</description><link>https://blog.swiftpackageindex.com/posts/keeping-up-to-date-with-swift-packages</link><pubDate>Wed, 25 Nov 2020 12:00:00 +0000</pubDate><content:encoded><![CDATA[<p>How do you keep up with new releases of the packages you use? How do you discover new packages? It‚Äôs a tough challenge to keep up to date with everything that the community releases, so we have some announcements today that can help you stay informed!</p><p>Before we get started with the announcements, we want to credit <a href="https://twitter.com/JamesSherlouk">James Sherlouk</a> for his invaluable contributions to building the Twitter updates feature. He was instrumental in getting this feature up and running and has been making other improvements in several areas of the site since we launched. Thank you, James!</p><h3>Updates via Twitter</h3><p>You may already be following the <a href="https://twitter.com/SwiftPackages">@SwiftPackages</a> account where we tweet occasional updates about the project. But as of yesterday, we‚Äôre also tweeting on the <a href="https://twitter.com/packagefirehose">@PackageFirehose</a> account. As you might guess by the name, this is a high volume account that posts <em>every time</em> there‚Äôs a new package added to the index, and <em>every time</em> there‚Äôs a new release of a package that we track. It‚Äôs around 20 tweets a day, if that counts as high volume!</p><picture class="shadow">
  <source srcset="/images/package-firehose-tweet~dark.png" media="(prefers-color-scheme: dark)">
  <img src="https://blog.swiftpackageindex.com/images/package-firehose-tweet~light.png" alt="A screenshot of a tweet from the package firehose account.">
</picture><p>While we‚Äôre on the subject of Twitter, we‚Äôd love to know what you‚Äôd like to see us do with the <a href="https://twitter.com/SwiftPackages">@SwiftPackages</a> account. We‚Äôve set up a <a href="https://iosdevweekly.typeform.com/to/t7uHYvXv">short survey</a> if you have a couple of minutes. We‚Äôd love to hear your opinions.</p><h3>Updates via RSS</h3><p>We‚Äôve had RSS support for a while now, but we‚Äôve not talked about it on the blog before, so it‚Äôs worth mentioning. If you‚Äôd prefer to keep up to date via a feed reader, or if you want fine-grained control over what type of package updates you‚Äôd like to be notified of then subscribe to one of our RSS feeds:</p><ul><li><a href="https://swiftpackageindex.com/packages.rss">New Packages</a> ‚Äì A feed with packages that are new to the Swift Package Index.</li><li><a href="https://swiftpackageindex.com/releases.rss">All Package Releases</a> ‚Äì A feed of all new package version releases.</li></ul><p>One advantage that these feeds have over Twitter is that they can be filtered with query string parameters. The package releases feed accepts four parameters; <code>major</code>, <code>minor</code>, <code>patch</code>, and <code>pre</code>. Pass <code>true</code> to any of these parameters to filter the feed on that part of the <a href="https://semver.org">semantic version number</a>. So, you can subscribe to <a href="https://swiftpackageindex.com/releases.rss?major=true">only major package release</a>, or <a href="https://swiftpackageindex.com/releases.rss?major=true&minor=true">major and minor package releases combined</a>, or if you <em>only</em> want to know about pre-release versions, <a href="https://swiftpackageindex.com/releases.rss?pre=true">you can find those here</a>. Use any permutation of the parameters to get exactly the feed that you want.</p><p>We hope you find both of these mechanisms for keeping up to date useful!</p>]]></content:encoded></item><item><guid isPermaLink="true">https://blog.swiftpackageindex.com/posts/the-swift-package-index-metadata-file-first-steps</guid><title>The Swift Package Index Metadata File ‚Äì First Steps</title><description>The Swift Package Index gathers most of the metadata about a package from external sources. The package manifest, the git repository, and GitHub. But, there are some things we need to know that are specific to the Swift Package Index. Learn how to take advantage of the extra settings available to your package.</description><link>https://blog.swiftpackageindex.com/posts/the-swift-package-index-metadata-file-first-steps</link><pubDate>Fri, 30 Oct 2020 12:00:00 +0000</pubDate><content:encoded><![CDATA[<p>The vast majority of the information you see in <a href="https://swiftpackageindex.com">the package index</a> is generated from a single URL, the location of the package‚Äôs git repository.</p><p>From that URL we gather data from the repository itself, the package manifest, the GitHub API (yes, it‚Äôs GitHub only for now, but <a href="https://github.com/SwiftPackageIndex/SwiftPackageIndex-Server/issues/485">we do plan to support other hosts</a>), and from running builds of the package to check compatibility with operating systems and Swift versions.</p><h2>Edge cases</h2><p>Of course, as with everything in software development, it‚Äôs not long before you find yourself talking about edge cases.</p><p>While creating <a href="posts/launching-language-and-platform-package-compatibility">the build system</a>, we quickly encountered packages where watchOS targets failed to build. We use Xcode‚Äôs automatic scheme creation functionality while running builds, but Xcode generates schemes that always include test targets, and <code>XCTest</code> isn‚Äôt available on watchOS. Using automatic schemes for watchOS builds wasn‚Äôt going to work.</p><p>The only way to have these builds succeed is for our build system to use a specific scheme, rather than an automatically created one. Many packages already have schemes for this purpose, but as package authors can give schemes any name, it‚Äôs not possible to easily discover them.</p><h2>Enter the Swift Package Index configuration file</h2><p>Rather than trying to keep the build system 100% generic, we needed a mechanism for package authors to specify some configuration information, such as the scheme name to use to build watchOS targets.</p><p>We support this via a configuration file, <code>.spi.yml</code> which we will look for in the root of your Swift package repository.</p><h3>Schemes for watchOS</h3><p>You can see the popular package <a href="https://github.com/pointfreeco/swift-composable-architecture"><code>swift-composable-architecture</code></a> by <a href="https://www.pointfree.co">Pointfree</a> making use of <a href="https://github.com/pointfreeco/swift-composable-architecture/blob/main/.spi.yml">this config file</a>:</p><pre><code class="language-yaml">version: 1
builder:
  configs:
  - platform: watchos
    scheme: ComposableArchitecture_watchOS
</code></pre><p>Our build servers look for this file and use any scheme information we find for each platform. If a platform isn‚Äôt listed, we use our default heuristics to determine the scheme as outlined in our <a href="https://swiftpackageindex.com/docs/builds#built-how">build FAQ</a>.</p><h3>Images for Linux</h3><p>Custom schemes aren‚Äôt all we support though. Package authors can also use the <code>.spi.yml</code> file to configure custom docker base images for our Linux builds.</p><p>We build packages for Linux with docker commands, selecting between the <a href="https://hub.docker.com/r/swiftlang/swift">various base images that Apple provide</a>.</p><pre><code class="language-bash">/usr/local/bin/docker run --rm -v "$PWD":/host -w /host swiftlang/swift:5.2.4 swift build --enable-test-discovery
</code></pre><p>This works well unless a package requires an OS-level dependency, like OpenSSL.</p><p>We may eventually provide our own set of base images for supported Swift versions that also include common dependencies like OpenSSL. For now, we are asking package authors whose builds fail due to missing dependencies to create their own for the Swift versions they support.</p><p>For security reasons, we don‚Äôt allow package authors to specify arbitrary images in the configuration file, so if you need to use this feature, please <a href="https://github.com/SwiftPackageIndex/SwiftPackageIndex-Server/issues/new">raise an issue asking for us to support a custom base image</a>.</p><p>The AWS library <a href="https://swiftpackageindex.com/soto-project/soto">Soto</a> is an example of a package that makes use of this feature in its <a href="https://github.com/soto-project/soto/blob/main/.spi.yml"><code>.spi.yml</code> file</a>:</p><pre><code class="language-yaml">version: 1
builder:
  configs:
  - platform: linux
    swift_version: '5.0'
    image: adamfowlerphoto/aws-sdk-swift:5.0
  - platform: linux
    swift_version: '5.1'
    image: adamfowlerphoto/aws-sdk-swift:5.1
  - platform: linux
    swift_version: '5.2'
    image: adamfowlerphoto/aws-sdk-swift:5.2
  - platform: linux
    swift_version: '5.3'
    image: adamfowlerphoto/aws-sdk-swift:5.3
</code></pre><h2>Future direction</h2><p>It‚Äôs early days for this configuration file. We created it to solve issues which package authors were facing trying to make sure that the language and platform compatibility we report reflects reality.</p><p>We expect this file to evolve, which is why it carries a version number. Here are some of the things we are planning to add over time, so that package authors can control them:</p><ul><li>Author metadata. Full name, blog URL, Twitter account, etc.</li><li>Package keywords or categories.</li><li>The location of any hosted documentation for a package.</li><li>Sponsorship or funding information for a package.</li></ul><p>More metadata possibilities are under discussion in <a href="https://github.com/SwiftPackageIndex/SwiftPackageIndex-Server/issues/435">this GitHub issue</a>. This is a great place to chime in if you have suggestions.</p><h2>File format</h2><p>We chose <code>YAML</code> as the file format because it is an uncontroversial, universally beloved format that is entirely <a href="https://www.arp242.net/yaml-config.html">free of issues</a>. üò¨</p><p>Seriously though, we chose YAML as it‚Äôs relatively easy for a human to read and write, and it‚Äôs well supported in Swift. While it has some downsides compared to JSON, we believe it‚Äôs a more practical format given that package authors need to create this file manually.</p><p>Of course, we‚Äôll let adoption be the guide as to how well it is working in practice!</p>]]></content:encoded></item><item><guid isPermaLink="true">https://blog.swiftpackageindex.com/posts/funding-the-future-of-the-swift-package-index</guid><title>Funding the Future of the Swift Package Index</title><description>Many open-source projects are just code and don‚Äôt need constant attention. The Swift Package Index is a little different, so we are opening up GitHub sponors for the project. We'd love your support.</description><link>https://blog.swiftpackageindex.com/posts/funding-the-future-of-the-swift-package-index</link><pubDate>Mon, 12 Oct 2020 12:00:00 +0000</pubDate><content:encoded><![CDATA[<p>It‚Äôs been almost four months since we <a href="https://iosdevweekly.com/issues/460#start">launched the Swift Package Index</a>, and we‚Äôve been so happy to see so many positive reactions to it across the community. Thank you all for checking it out and spreading the word.</p><p>It‚Äôs still early days for Swift Package Manager adoption but we are confident that it will become the dominant technology for Swift dependency management, and we want the Swift Package Index to grow right alongside it.</p><p>We believe we‚Äôre off to a great start with what we have so far, but this is only the beginning. We have so many ideas for ‚Äú<a href="https://github.com/SwiftPackageIndex/SwiftPackageIndex-Server/issues">bug fixes and improvements</a>‚Äù! üòÇ</p><p>Many open-source projects are just code and don‚Äôt need constant maintenance and monitoring, but the Swift Package Index is a little different. It‚Äôs a hosted instance of the site with a <a href="https://blog.swiftpackageindex.com/posts/launching-language-and-platform-package-compatibility/">reasonably complex automated build system</a> that has run over 600,000 builds so far (increasing by 7,000 more every day!). It takes significant time and effort to keep things running smoothly.</p><p>We want to find a way to make sure that we can continue to give this site the time and attention it needs, but we don‚Äôt really want to go down the route of including advertising. Instead, we are opening up <a href="https://github.com/sponsors/SwiftPackageIndex">sponsorship on GitHub</a>.</p><p>If you (or your company) would like to support the site, we would be thrilled to be able to make this a community-funded effort for years to come.</p><p><a href="https://github.com/sponsors/SwiftPackageIndex"><img src="https://blog.swiftpackageindex.com/images/sponsorship-goal-100-sponsors.png" alt="A screenshot of our GitHub sponsors goal showing 1% of 100 sponsors."/></a></p><p>Also, a huge thanks to <a href="https://twitter.com/cocoanetics">Oliver</a>, who beat us to even announcing this by sponsoring the project yesterday! Thanks for being our very first sponsor. üòç</p><p>Thank you!<br>Dave &amp; Sven</p>]]></content:encoded></item><item><guid isPermaLink="true">https://blog.swiftpackageindex.com/posts/building-3238-packages-for-apple-silicon</guid><title>Building 3,238 Swift Packages for Apple Silicon</title><description>As part of the Swift Package Index build system, we have processed what must be the most extensive test of Apple Silicon compatibility outside of Apple. Here‚Äôs what we found.</description><link>https://blog.swiftpackageindex.com/posts/building-3238-packages-for-apple-silicon</link><pubDate>Wed, 9 Sep 2020 12:00:00 +0000</pubDate><content:encoded><![CDATA[<p>As part of the <a href="https://blog.swiftpackageindex.com/posts/launching-language-and-platform-package-compatibility/">Swift Package Index build system</a>, we have processed what must be the most extensive test of Apple Silicon compatibility outside of Apple.</p><p>At the time of writing, we currently have 12,942 Apple Silicon builds in our database covering 3,238 packages. Why so many? We test up to <a href="https://swiftpackageindex.com/SwifQL/SwifQL/builds">three versions of each package</a> and compile each version with both <code>xcodebuild</code> and <code>swift build</code>.</p><p>I‚Äôm sure that many of the Apple Silicon DTK machines Apple shipped around the world are working very hard, testing apps for compatibility, but I‚Äôm not sure any of them have worked quite as hard as ours has. üöÄ</p><h2>What did we find?</h2><p>As you might expect, there‚Äôs plenty of good news. For packages with successful Intel builds, the <em>vast majority</em> also successfully build for Apple Silicon. üëç</p><p>There are failures, though, and the most interesting failures are where the build fails on Apple Silicon while the corresponding Intel build succeeds. In cases like this, that indicates a compatibility issue that will potentially need some attention from the package author. We‚Äôve identified 139 packages (~4%) where this is the case, and have <a href="https://gist.github.com/daveverwer/ae08ad14a7a975e0488503282b4f1dbf">compiled a list of them for reference</a>.</p><p>There are a few common errors that we‚Äôre observing in these failures, and most of them are from one of the following problems:</p><ul><li>Any inline assembly will fail, obviously!</li><li><code>Float80</code> is unavailable.</li><li><code>x86_thread_state64_t</code> is unavailable.</li><li><code>__darwin_arm_thread_state64' has no member '__rsp'</code>.</li><li><code>cannot convert value of type 'CVaListPointer' to expected argument type '__darwin_va_list?'</code>.</li><li>Sometimes, the compiler crashes!</li></ul><p>Even though 139 failing packages might sound like a lot, it‚Äôs not that bad, especially when you consider that many of the failures all fail due to an issue in a common base dependency, <a href="https://swiftpackageindex.com/PerfectlySoft/Perfect"><code>PerfectLib</code></a>.</p><h2>Where do we go from here?</h2><p>Even though the results are generally positive, it does show that there‚Äôs a bit of work that the community need to do to ensure the transition to Apple Silicon is as smooth as possible.</p><p>If you‚Äôre a package author and do not have a DTK machine at your disposal, please feel free to use ours via the Swift Package Index build system! Make changes to your packages, push them to a pre-release tag (for example, X.X.X-arm-beta-X) and the build system will pick up that tag and build it. You should see new build results, usually within a couple of hours of pushing a tag.</p><p>If you have any problems with the build system, there‚Äôs a couple of ways to contact us. We‚Äôre in the <code>#swiftpackageindex</code> channel over at the <a href="https://swift-package-manager.herokuapp.com">SwiftPM Slack</a>, or if it looks like there might be something wrong, please <a href="https://github.com/SwiftPackageIndex/SwiftPackageIndex-Server/issues/new">raise an issue on GitHub</a>.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://blog.swiftpackageindex.com/posts/launching-language-and-platform-package-compatibility</guid><title>Launching Language and Platform Package Compatibility</title><description>We decided that one of the most important pieces of information we could provide on a package metadata page was what versions of Swift, and what platforms it was compatible with. Building that feature turned out to be quite an epic journey.</description><link>https://blog.swiftpackageindex.com/posts/launching-language-and-platform-package-compatibility</link><pubDate>Thu, 20 Aug 2020 12:00:00 +0000</pubDate><content:encoded><![CDATA[<p>What‚Äôs the first question you need an answer to after finding a package that fits your needs?</p><blockquote><p>‚ÄúDoes this package work with the Swift version and platform that my app uses?‚Äù</p></blockquote><p>When we initially launched the Swift Package Index, we attempted to answer this question with the metadata available in the package manifest. Namely the <a href="https://developer.apple.com/documentation/swift_packages/package/3197887-swiftlanguageversions"><code>swiftLanguageVersions</code></a> and <a href="https://developer.apple.com/documentation/swift_packages/package/3197886-platforms"><code>platforms</code></a> properties.</p><p>The problem is that neither of those properties is perfect. <code>swiftLanguageVersions</code> isn‚Äôt granular enough, only <a href="https://developer.apple.com/documentation/swift_packages/swiftversion">officially</a> allowing values of <code>v4</code>, <code>v4_2</code>, and <code>v5</code>. The <code>platforms</code> property is better, but doesn‚Äôt let package authors declare compatibility with non-Apple operating systems such as Linux.</p><p>Wouldn‚Äôt it be fantastic if you could see a matrix like this for <em>every</em> package? üòç</p><picture class="shadow">
  <source srcset="/images/promisekit-language-and-platform-metadata~dark.png" media="(prefers-color-scheme: dark)">
  <img src="https://blog.swiftpackageindex.com/images/promisekit-language-and-platform-metadata~light.png" alt="The language and platform compatibility matrix for PromiseKit.">
</picture><p>Look at how information-rich that matrix is. You can instantly see that the latest stable version of <a href="https://swiftpackageindex.com/mxcl/PromiseKit">PromiseKit</a> is compatible with every version of Swift back to 4.2, and every platform, including Linux. Then, you can see that the alpha version in development drops support for iOS, tvOS, and watchOS, and Swift 4.2. That seems suspicious, right? Keep looking, and you‚Äôll see that the default branch fixes all those issues and restores compatibility. I‚Äôm confident looking at that matrix that when 7.0.0 is released, it‚Äôll have green ticks across the board, but I also know to not depend on this current alpha. That‚Äôs practical, actionable information.</p><p>When we started thinking about how best to solve this problem, the obvious best solution was to build the packages! What better way to see if a package is compatible with Swift 4.2 than to build it with the version of <code>xcodebuild</code> that shipped with Xcode 10.1.</p><p>So that‚Äôs what we did, and it‚Äôs available right now. Why not <a href="https://swiftpackageindex.com">give it a try</a> by searching for a few of your favourite packages? üöÄ</p><h3>Accurate, real-world compatibility data</h3><p>It‚Äôs a little more complicated than ‚Äújust build each package‚Äù though. A package might build with Swift 5.2 on iOS, but that same build might fail using Swift 5.2 on macOS due to a UIKit dependency, or other macOS specific issue. What‚Äôs needed is a <em>matrix</em> of builds to generate an accurate picture of compatibility.</p><p>So, if we run builds using Swift 5.1 on iOS, macOS, tvOS, watchOS, and with Linux and <em>any</em> of them pass, it‚Äôs compatible with Swift 5.2. If <em>any</em> version of Swift builds without failure on iOS, then the package supports iOS.</p><p>We ended up with a platform list of:</p><ul><li>iOS using <code>xcodebuild</code></li><li>macOS using <code>xcodebuild</code></li><li>macOS using <code>swift build</code> (there are good reasons where <code>swift build</code> would pass in circumstances where <code>xcodebuild</code> might fail)</li><li>macOS using <code>xcodebuild</code> on Apple Silicon (yes, compiled using a DTK!)</li><li>macOS using <code>swift build</code> on Apple Silicon</li><li>tvOS using <code>xcodebuild</code></li><li>watchOS using <code>xcodebuild</code></li><li>Linux using <code>swift build</code></li></ul><p>We then decided on a list of Swift compiler versions we‚Äôd like to check compatibility with:</p><ul><li>Swift 4.2 (4.2.1)</li><li>Swift 5.0 (5.0.1)</li><li>Swift 5.1 (5.1.3)</li><li>Swift 5.2 (5.2.4)</li><li>Swift 5.3 (beta)</li></ul><p>That‚Äôs up to 32 builds per package, but that‚Äôs just the beginning. What if there‚Äôs a stable release and a beta release? The stable version might support Swift 4.2 and higher, and the new beta might drop support for anything less than Swift 5.2. That‚Äôs information which would be important when choosing a package, so we need to show it. As we also track the status of the default branch, we must build that too, and we‚Äôve quickly arrived at a place where we might need to run 96 builds <em>per package</em>! With almost 3,200 packages in the index, that‚Äôs potentially more than 300,000 builds! üòÖ</p><p>In practice, it‚Äôs less than that as most packages don‚Äôt have a current beta release, but it‚Äôs still a <em>lot</em> of builds. We‚Äôve processed more than 200,000 builds as I write this, and we‚Äôre not quite finished. As of today, we‚Äôre at 99% though, so we almost made it before launch! üò¨</p><p>If you‚Äôve been following <a href="https://twitter.com/daveverwer/status/1291808885259620353">these tweets</a>, it should be obvious what all that processing was! Let‚Äôs take a look at the last <strong>30 days</strong> of CPU graphs for our production server, a 2018 Mac mini with 32Gb RAM and a 6-core i7 CPU:</p><img src="https://blog.swiftpackageindex.com/images/production-server-thirty-day-cpu-graph.png" alt="A graph showing a few spikes of CPU activity, followed by a sustained 100% CPU load."/><p>You can see a few of our final test runs in that graph, and then we started processing for real. Since then, we‚Äôve kept the CPU completely pegged for more than two weeks. We‚Äôve also had our staging Mac mini, a spare 2016 MacBook Pro, and a DTK working on builds too.</p><h3>Everyone loves badges</h3><p>Providing compatibility information on this site is one thing, but everyone loves adorning their packages pages with <a href="https://shields.io">shields.io</a> badges, don‚Äôt they? If you maintain an open-source project, wouldn‚Äôt you like to show off real compatibility status in your README file, like this?</p><img src="https://blog.swiftpackageindex.com/images/rester-readme-with-spi-badges.png" alt="A screenshot of a GitHub page with badges that show the Swift and platform compatibility for the package."/><p>If you‚Äôre a package author, click the ‚ÄúCopy badge‚Äù button below each of the compatibility matrices and you‚Äôll have a Markdown image link in your clipboard, ready to use.</p><p>Your users will always see live, accurate compatibility information that updates whenever you release a new version.</p><h3>Credit where it‚Äôs due!</h3><p>First of all, we‚Äôd like to thank our kind friends at <a href="https://macstadium.com">MacStadium</a> for providing the significant hosting resources for this project as part of their <a href="https://www.macstadium.com/opensource">open-source programme</a>. At one point we were a little concerned that we might melt their machines, and we very glad that we didn‚Äôt. They‚Äôve performed incredibly.</p><p>We also want to say thank you to <a href="https://twitter.com/aciidb0mb3r">Ankit Aggarwal</a> and <a href="https://twitter.com/neonacho">Boris B√ºgling</a> of Apple. Their tireless help and support on the <a href="https://swift-package-manager.herokuapp.com">SwiftPM Slack</a> saved us countless hours figuring out the correct way to approach this problem.</p><p>Finally, we‚Äôd love to say thank you to everyone who provided help and feedback along the way as we built this feature. We couldn‚Äôt have done it without any of you.</p><h3>Wrapping up</h3><p>Some package authors set up continuous integration for their packages and of course, that includes a build step. That usually only covers one version of Swift though, and the information gets hidden away in a different place in each repo. We think that by centralising this data and making it available for <em>all</em> packages, we should be able to help this community make better decisions about their dependencies, and that‚Äôs what this site is all about.</p><p>We hope you love this feature as much as we do! ‚ù§Ô∏è</p>]]></content:encoded></item><item><guid isPermaLink="true">https://blog.swiftpackageindex.com/posts/say-hello-to-the-swift-package-index-blog</guid><title>Say Hello to the Swift Package Index Blog</title><description>It‚Äôs always hard to know when to ship v1 of a project. Which features get included? Are there things that can wait? It‚Äôs a balancing act. You‚Äôre excited to show the world what you built, but is it good enough?</description><link>https://blog.swiftpackageindex.com/posts/say-hello-to-the-swift-package-index-blog</link><pubDate>Sun, 16 Aug 2020 12:00:00 +0000</pubDate><content:encoded><![CDATA[<p>Hello! üëã</p><p>It‚Äôs always hard to know when to ship v1 of a project. Which features get included? Are there things that can wait? It‚Äôs a balancing act. You‚Äôre excited to show the world what you built, but is it good enough?</p><p>One decision we made when shipping the <a href="https://swiftpackageindex.com">Swift Package Index</a> was that a blog could wait. Looking back now, it feels like that was the right decision. The launch went smoothly, you all reacted very kindly and positively to it, and we went back to work fixing bugs and working on new features.</p><p>However, we always knew we‚Äôd need somewhere to write about what we are doing with this project. We‚Äôd love to tell you about some of the interesting technical challenges we faced, but most of all we want to tell you about the new features we‚Äôve been building...</p><p>What features? You‚Äôll have to wait just one more week to find out what we‚Äôve been working on, but we‚Äôre pretty excited about it, and that‚Äôs why now was the right time to launch this blog.</p><p class="dim">Now we just need to keep writing on it! üò¨</p>]]></content:encoded></item></channel></rss>